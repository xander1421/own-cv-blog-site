---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
  title="Chatter - Join the Waitlist"
  description="Be among the first to experience Chatter - a secure, real-time chat platform with end-to-end encryption, voice/video calling, and AI integrations."
  image="/chatter-og.png"
  type="website"
>
  <div class="waitlist-container">
    <!-- Hero Section with Blackhole Effect -->
    <section class="hero-section">
      <canvas id="blackhole-canvas" class="blackhole-canvas"></canvas>
      
      <div class="hero-content">
        <div class="logo-container">
          <h1 class="logo-text">CHATTER</h1>
          <div class="logo-pulse"></div>
        </div>
        
        <h2 class="tagline">The Future of Secure Communication</h2>
        
        <p class="hero-description">
          Experience real-time chat with military-grade encryption, powered by the Signal Protocol.
          Voice & video calls, AI integrations, and complete privacy‚Äîall in one platform.
        </p>

        <div class="features-grid">
          <div class="feature-card">
            <div class="feature-icon">üîê</div>
            <h3>End-to-End Encryption</h3>
            <p>Signal Protocol with perfect forward secrecy</p>
          </div>
          
          <div class="feature-card">
            <div class="feature-icon">üé•</div>
            <h3>Voice & Video</h3>
            <p>Crystal-clear calls with LiveKit integration</p>
          </div>
          
          <div class="feature-card">
            <div class="feature-icon">ü§ñ</div>
            <h3>AI Powered</h3>
            <p>Smart assistants and content moderation</p>
          </div>
          
          <div class="feature-card">
            <div class="feature-icon">üìÅ</div>
            <h3>File Sharing</h3>
            <p>Resumable uploads with encryption</p>
          </div>
        </div>

        <!-- Waitlist Form -->
        <div class="waitlist-form-container">
          <h3 class="form-title">Join the Waitlist</h3>
          <p class="form-subtitle">Be the first to know when we launch</p>
          
          <form id="waitlist-form" class="waitlist-form">
            <div class="input-group">
              <input 
                type="email" 
                id="email" 
                name="email" 
                placeholder="Enter your email address"
                class="email-input"
                required
                pattern="[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}$"
              />
              <button type="submit" class="submit-btn">
                <span class="btn-text">Join Now</span>
                <svg class="btn-arrow" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <line x1="5" y1="12" x2="19" y2="12"></line>
                  <polyline points="12 5 19 12 12 19"></polyline>
                </svg>
              </button>
            </div>
            <div id="form-message" class="form-message"></div>
          </form>
        </div>

        <div class="stats-container">
          <div class="stat">
            <span class="stat-number">12</span>
            <span class="stat-label">Services</span>
          </div>
          <div class="stat">
            <span class="stat-number">DDD</span>
            <span class="stat-label">Architecture</span>
          </div>
          <div class="stat">
            <span class="stat-number">E2E</span>
            <span class="stat-label">Encrypted</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Technical Details Section -->
    <section class="tech-section">
      <h2 class="section-title">Built Different</h2>
      
      <div class="tech-grid">
        <div class="tech-card">
          <h3>Domain-Driven Design</h3>
          <p>Modular monolith architecture with clear service boundaries, dependency injection, and the flexibility to scale into microservices when needed.</p>
          <a href="/blog/why-i-chose-monolithic-architecture-for-chatter" class="tech-link">Learn more ‚Üí</a>
        </div>
        
        <div class="tech-card">
          <h3>Signal Protocol</h3>
          <p>Military-grade encryption with X3DH key exchange, Double Ratchet algorithm, and Sealed Sender for complete metadata privacy.</p>
          <a href="/blog/signal-protocol-implementation-in-chatter" class="tech-link">Deep dive ‚Üí</a>
        </div>
        
        <div class="tech-card">
          <h3>Post-Quantum Ready</h3>
          <p>Hybrid cryptography combining Curve25519 with Kyber KEM, ensuring your messages stay secure even against quantum computers.</p>
        </div>
      </div>

      <div class="tech-stack">
        <h3>Technology Stack</h3>
        <div class="tech-badges">
          <span class="tech-badge">Go</span>
          <span class="tech-badge">React 19</span>
          <span class="tech-badge">TypeScript</span>
          <span class="tech-badge">PostgreSQL</span>
          <span class="tech-badge">Redis</span>
          <span class="tech-badge">ConnectRPC</span>
          <span class="tech-badge">Temporal</span>
          <span class="tech-badge">SpiceDB</span>
          <span class="tech-badge">LiveKit</span>
          <span class="tech-badge">Vault</span>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="waitlist-footer">
      <p>¬© 2025 Chatter. Built with passion by <a href="/" class="footer-link">Alexandru Pruteanu</a></p>
      <div class="footer-links">
        <a href="/blog" class="footer-link">Blog</a>
        <a href="https://github.com/xander1421" class="footer-link">GitHub</a>
        <a href="https://linkedin.com/in/alexandru-prt" class="footer-link">LinkedIn</a>
      </div>
    </footer>
  </div>
</BaseLayout>

<style>
  .waitlist-container {
    min-height: 100vh;
    background: #000000;
    color: #ffffff;
    overflow-x: hidden;
  }

  /* Hero Section */
  .hero-section {
    position: relative;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
  }

  .blackhole-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    opacity: 0.8;
  }

  .hero-content {
    position: relative;
    z-index: 2;
    max-width: 1200px;
    width: 100%;
    text-align: center;
  }

  .logo-container {
    position: relative;
    display: inline-block;
    margin-bottom: 2rem;
  }

  .logo-text {
    font-size: 5rem;
    font-weight: 900;
    letter-spacing: 0.1em;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0;
    animation: glow 3s ease-in-out infinite;
  }

  @keyframes glow {
    0%, 100% { filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.5)); }
    50% { filter: drop-shadow(0 0 40px rgba(240, 147, 251, 0.8)); }
  }

  .logo-pulse {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 150%;
    height: 150%;
    background: radial-gradient(circle, rgba(102, 126, 234, 0.2) 0%, transparent 70%);
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.2; }
  }

  .tagline {
    font-size: 2rem;
    font-weight: 300;
    margin-bottom: 1.5rem;
    color: #a0a0a0;
  }

  .hero-description {
    font-size: 1.25rem;
    line-height: 1.8;
    max-width: 700px;
    margin: 0 auto 3rem;
    color: #cccccc;
  }

  /* Features Grid */
  .features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 2rem;
    margin-bottom: 4rem;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
  }

  .feature-card {
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.5rem;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  .feature-card:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(102, 126, 234, 0.5);
    transform: translateY(-4px);
  }

  .feature-icon {
    font-size: 2.5rem;
    margin-bottom: 1rem;
  }

  .feature-card h3 {
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: #ffffff;
  }

  .feature-card p {
    font-size: 0.9rem;
    color: #999999;
    line-height: 1.5;
  }

  /* Waitlist Form */
  .waitlist-form-container {
    max-width: 500px;
    margin: 0 auto 4rem;
    padding: 2rem;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    backdrop-filter: blur(20px);
  }

  .form-title {
    font-size: 1.8rem;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .form-subtitle {
    color: #999999;
    margin-bottom: 2rem;
  }

  .input-group {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .email-input {
    flex: 1;
    padding: 1rem 1.5rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    color: #ffffff;
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  .email-input::placeholder {
    color: #666666;
  }

  .email-input:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(102, 126, 234, 0.5);
    box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
  }

  .submit-btn {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border: none;
    border-radius: 12px;
    color: #ffffff;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .submit-btn:hover {
    transform: translateX(4px);
    box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
  }

  .btn-arrow {
    transition: transform 0.3s ease;
  }

  .submit-btn:hover .btn-arrow {
    transform: translateX(4px);
  }

  .form-message {
    text-align: center;
    font-size: 0.95rem;
    padding: 0.75rem;
    border-radius: 8px;
    display: none;
  }

  .form-message.success {
    display: block;
    background: rgba(74, 222, 128, 0.1);
    border: 1px solid rgba(74, 222, 128, 0.3);
    color: #4ade80;
  }

  .form-message.error {
    display: block;
    background: rgba(248, 113, 113, 0.1);
    border: 1px solid rgba(248, 113, 113, 0.3);
    color: #f87171;
  }

  /* Stats Container */
  .stats-container {
    display: flex;
    justify-content: center;
    gap: 4rem;
    margin-top: 3rem;
  }

  .stat {
    text-align: center;
  }

  .stat-number {
    display: block;
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .stat-label {
    display: block;
    font-size: 0.9rem;
    color: #666666;
    margin-top: 0.5rem;
  }

  /* Tech Section */
  .tech-section {
    padding: 5rem 2rem;
    max-width: 1200px;
    margin: 0 auto;
  }

  .section-title {
    font-size: 3rem;
    text-align: center;
    margin-bottom: 3rem;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .tech-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
    margin-bottom: 4rem;
  }

  .tech-card {
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 2rem;
    transition: all 0.3s ease;
  }

  .tech-card:hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: rgba(240, 147, 251, 0.3);
  }

  .tech-card h3 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    color: #ffffff;
  }

  .tech-card p {
    color: #999999;
    line-height: 1.7;
    margin-bottom: 1rem;
  }

  .tech-link {
    color: #667eea;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
  }

  .tech-link:hover {
    color: #f093fb;
  }

  .tech-stack {
    text-align: center;
    margin-top: 4rem;
  }

  .tech-stack h3 {
    font-size: 1.5rem;
    margin-bottom: 2rem;
    color: #ffffff;
  }

  .tech-badges {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
  }

  .tech-badge {
    padding: 0.5rem 1.5rem;
    background: rgba(102, 126, 234, 0.1);
    border: 1px solid rgba(102, 126, 234, 0.3);
    border-radius: 25px;
    font-size: 0.9rem;
    color: #667eea;
    transition: all 0.3s ease;
  }

  .tech-badge:hover {
    background: rgba(102, 126, 234, 0.2);
    transform: translateY(-2px);
  }

  /* Footer */
  .waitlist-footer {
    padding: 3rem 2rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
    color: #666666;
  }

  .footer-links {
    display: flex;
    justify-content: center;
    gap: 2rem;
    margin-top: 1rem;
  }

  .footer-link {
    color: #999999;
    text-decoration: none;
    transition: color 0.3s ease;
  }

  .footer-link:hover {
    color: #667eea;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .logo-text {
      font-size: 3rem;
    }

    .tagline {
      font-size: 1.5rem;
    }

    .hero-description {
      font-size: 1.1rem;
    }

    .features-grid {
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .input-group {
      flex-direction: column;
    }

    .submit-btn {
      width: 100%;
      justify-content: center;
    }

    .stats-container {
      gap: 2rem;
    }

    .tech-grid {
      grid-template-columns: 1fr;
    }
  }
</style>

<script>
  // Interstellar-style blackhole effect from Chatter frontend (converted to vanilla JS)
  const canvas = document.getElementById('blackhole-canvas') as HTMLCanvasElement;
  if (canvas) {
    const gl = canvas.getContext('webgl2', { 
      alpha: true,
      antialias: true,
      powerPreference: 'high-performance',
      preserveDrawingBuffer: false
    }) || canvas.getContext('webgl', {
      alpha: true,
      antialias: true,
      powerPreference: 'high-performance',
      preserveDrawingBuffer: false
    });

    if (gl) {
      // Vertex shader
      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        
        void main() {
          v_uv = a_position;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Fragment shader - High quality Interstellar black hole
      const fragmentShaderSource = `
        precision highp float;
        
        varying vec2 v_uv;
        uniform float u_time;
        uniform vec2 u_resolution;
        
        #define AA 1
        #define _Speed 3.0
        #define _Steps 8.0
        #define _Size 0.4
        
        float hash(float x) { 
          return fract(sin(x) * 152754.742);
        }
        
        float hash(vec2 x) {    
          return hash(x.x + hash(x.y));
        }
        
        float value(vec2 p, float f) {
          float bl = hash(floor(p * f + vec2(0., 0.)));
          float br = hash(floor(p * f + vec2(1., 0.)));
          float tl = hash(floor(p * f + vec2(0., 1.)));
          float tr = hash(floor(p * f + vec2(1., 1.)));
          
          vec2 fr = fract(p * f);    
          fr = (3.0 - 2.0 * fr) * fr * fr;    
          float b = mix(bl, br, fr.x);    
          float t = mix(tl, tr, fr.x);
          return mix(b, t, fr.y);
        }
        
        vec4 background(vec3 ray) {
          vec2 uv = ray.xy;
          
          if (abs(ray.x) > 0.5)
            uv.x = ray.z;
          else if (abs(ray.y) > 0.5)
            uv.y = ray.z;
          
          float brightness = value(uv * 3.0, 100.0);
          float color = value(uv * 2.0, 20.0); 
          brightness = pow(brightness, 256.0);
          brightness = brightness * 100.0;
          brightness = clamp(brightness, 0.0, 1.0);
          
          vec3 stars = brightness * mix(vec3(0.5, 0.5, 0.6), vec3(0.3, 0.3, 0.4), color) * 0.5;
          
          vec3 nebulae = vec3(0.0);
          float nebula = value(uv * 0.5, 5.0);
          nebula = pow(nebula, 8.0) * 0.02;
          nebulae = vec3(nebula) * vec3(0.2, 0.1, 0.3);
          
          return vec4(stars + nebulae, 1.0);
        }
        
        vec4 raymarchDisk(vec3 ray, vec3 zeroPos) {
          vec3 position = zeroPos;      
          float lengthPos = length(position.xz);
          float dist = min(1.0, lengthPos * (1.0 / _Size) * 0.5) * _Size * 0.4 * (1.0 / _Steps) / abs(ray.y);
          
          position += dist * _Steps * ray * 0.5;     
          
          vec2 deltaPos;
          deltaPos.x = -zeroPos.z * 0.01 + zeroPos.x;
          deltaPos.y = zeroPos.x * 0.01 + zeroPos.z;
          deltaPos = normalize(deltaPos - zeroPos.xz);
          
          float parallel = dot(ray.xz, deltaPos);
          parallel /= sqrt(lengthPos);
          parallel *= 0.5;
          float redShift = parallel + 0.3;
          redShift *= redShift;
          redShift = clamp(redShift, 0.0, 1.0);
          
          float disMix = clamp((lengthPos - _Size * 2.0) * (1.0 / _Size) * 0.24, 0.0, 1.0);
          vec3 insideCol = mix(vec3(0.9, 0.3, 0.9), vec3(0.3, 0.1, 0.3), disMix);
          
          insideCol *= mix(vec3(0.5, 0.3, 0.5), vec3(2.0, 1.0, 2.0), redShift);
          insideCol *= 1.0;
          redShift += 0.12;
          redShift *= redShift;
          
          vec4 o = vec4(0.0);
          
          for (float i = 0.0; i < _Steps; i++) {                      
            position -= dist * ray;  
            
            float intensity = clamp(1.0 - abs((i - 0.8) * (1.0 / _Steps) * 2.0), 0.0, 1.0); 
            float lengthPos = length(position.xz);
            float distMult = 1.0;
            
            distMult *= clamp((lengthPos - _Size * 0.75) * (1.0 / _Size) * 1.5, 0.0, 1.0);        
            distMult *= clamp((_Size * 10.0 - lengthPos) * (1.0 / _Size) * 0.20, 0.0, 1.0);
            distMult *= distMult;
            
            float u = lengthPos + u_time * _Size * 0.3 + intensity * _Size * 0.2;
            
            vec2 xy;
            float rot = mod(u_time * _Speed, 8192.0);
            xy.x = -position.z * sin(rot) + position.x * cos(rot);
            xy.y = position.x * sin(rot) + position.z * cos(rot);
            
            float x = abs(xy.x / xy.y);         
            float angle = 0.02 * atan(x);
            
            const float f = 70.0;
            float noise = value(vec2(angle, u * (1.0 / _Size) * 0.05), f);
            noise = noise * 0.66 + 0.33 * value(vec2(angle, u * (1.0 / _Size) * 0.05), f * 2.0);     
            
            float extraWidth = noise * 1.0 * (1.0 - clamp(i * (1.0 / _Steps) * 2.0 - 1.0, 0.0, 1.0));
            
            float alpha = clamp(noise * (intensity + extraWidth) * ((1.0 / _Size) * 10.0 + 0.01) * dist * distMult, 0.0, 1.0);
            
            vec3 col = 2.0 * mix(vec3(0.3, 0.2, 0.15) * insideCol, insideCol, min(1.0, intensity * 2.0));
            o = clamp(vec4(col * alpha + o.rgb * (1.0 - alpha), o.a * (1.0 - alpha) + alpha), vec4(0.0), vec4(1.0));
            
            lengthPos *= (1.0 / _Size);
            
            o.rgb += redShift * (intensity * 1.0 + 0.5) * (1.0 / _Steps) * 100.0 * distMult / (lengthPos * lengthPos);
          }  
          
          o.rgb = clamp(o.rgb - 0.005, 0.0, 1.0);
          return o;
        }
        
        void Rotate(inout vec3 vector, vec2 angle) {
          vector.yz = cos(angle.y) * vector.yz + sin(angle.y) * vec2(-1, 1) * vector.zy;
          vector.xz = cos(angle.x) * vector.xz + sin(angle.x) * vec2(-1, 1) * vector.zx;
        }
        
        void main() {
          vec4 colOut = vec4(0.0);
          
          vec2 fragCoord = gl_FragCoord.xy;
          
          vec2 fragCoordRot;
          fragCoordRot.x = fragCoord.x * 0.985 + fragCoord.y * 0.174;
          fragCoordRot.y = fragCoord.y * 0.985 - fragCoord.x * 0.174;
          fragCoordRot += vec2(-0.06, 0.12) * u_resolution.xy;
          
          for (int j = 0; j < AA; j++)
          for (int i = 0; i < AA; i++) {
            vec3 ray = normalize(vec3((fragCoordRot - u_resolution.xy * 0.5 + vec2(float(i), float(j)) / float(AA)) / u_resolution.x, 1.0)); 
            vec3 pos = vec3(0.0, 0.05, -10.0);
            vec2 angle = vec2(u_time * 0.1, 0.2);      
            angle.y = 3.14 + 0.1 + 3.14;
            float dist = length(pos);
            Rotate(pos, angle);
            angle.xy -= min(0.3 / dist, 3.14) * vec2(1.0, 0.5);
            Rotate(ray, angle);
            
            vec4 col = vec4(0.0); 
            vec4 glow = vec4(0.0); 
            vec4 outCol = vec4(100.0);
            
            for (int disks = 0; disks < 12; disks++) {
              for (int h = 0; h < 4; h++) {
                float dotpos = dot(pos, pos);
                float invDist = inversesqrt(dotpos);
                float centDist = dotpos * invDist;
                float stepDist = 0.92 * abs(pos.y / ray.y);
                float farLimit = centDist * 0.5;
                float closeLimit = centDist * 0.1 + 0.05 * centDist * centDist * (1.0 / _Size);
                stepDist = min(stepDist, min(farLimit, closeLimit));
                
                float invDistSqr = invDist * invDist;
                float bendForce = stepDist * invDistSqr * _Size * 0.625;
                ray = normalize(ray - (bendForce * invDist) * pos);
                pos += stepDist * ray; 
                
                glow += vec4(0.9, 0.3, 0.9, 1.0) * (0.01 * stepDist * invDistSqr * invDistSqr * clamp(centDist * 2.0 - 1.2, 0.0, 1.0));
              }
              
              float dist2 = length(pos);
              
              if (dist2 < _Size * 0.1) {
                outCol = vec4(col.rgb * col.a + glow.rgb * (1.0 - col.a), 1.0);
                break;
              }
              else if (dist2 > _Size * 1000.0) {                   
                vec4 bg = background(ray);
                outCol = vec4(col.rgb * col.a + bg.rgb * (1.0 - col.a) + glow.rgb * (1.0 - col.a), 1.0);       
                break;
              }
              else if (abs(pos.y) <= _Size * 0.002) {                             
                vec4 diskCol = raymarchDisk(ray, pos);
                pos.y = 0.0;
                pos += abs(_Size * 0.001 / ray.y) * ray;  
                col = vec4(diskCol.rgb * (1.0 - col.a) + col.rgb, col.a + diskCol.a * (1.0 - col.a));
              }    
            }
            
            if (outCol.r == 100.0)
              outCol = vec4(col.rgb + glow.rgb * (col.a + glow.a), 1.0);
            
            col = outCol;
            col.rgb = pow(col.rgb, vec3(0.6));
            
            colOut += col / float(AA * AA);
          }
          
          gl_FragColor = colOut;
        }
      `;

      // Compile shader function
      function compileShader(type: number, source: string): WebGLShader | null {
        const shader = gl.createShader(type);
        if (!shader) return null;
        
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        
        return shader;
      }

      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
      
      if (vertexShader && fragmentShader) {
        const program = gl.createProgram();
        if (program) {
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          
          if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
            // Setup geometry
            const positions = new Float32Array([
              -1, -1, 1, -1, -1, 1, 1, 1
            ]);
            
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            
            gl.useProgram(program);
            
            let startTime = Date.now();
            let animationId: number;
            let isVisible = true;
            
            function resizeCanvas() {
              const rect = canvas.getBoundingClientRect();
              const scale = window.innerWidth > 768 ? 0.5 : 0.75; // Better performance on desktop
              canvas.width = Math.floor(rect.width * scale);
              canvas.height = Math.floor(rect.height * scale);
            }
            
            function render() {
              if (!isVisible) {
                animationId = requestAnimationFrame(render);
                return;
              }
              
              gl.viewport(0, 0, canvas.width, canvas.height);
              gl.uniform1f(timeLocation, (Date.now() - startTime) / 1000);
              gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              
              animationId = requestAnimationFrame(render);
            }
            
            // Setup visibility observer for performance
            const observer = new IntersectionObserver(
              (entries) => {
                isVisible = entries[0]?.isIntersecting ?? false;
              },
              { threshold: 0.1 }
            );
            
            observer.observe(canvas);
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            render();
            
            // Cleanup on page navigation
            window.addEventListener('beforeunload', () => {
              observer.disconnect();
              cancelAnimationFrame(animationId);
              gl.deleteProgram(program);
              gl.deleteShader(vertexShader);
              gl.deleteShader(fragmentShader);
              gl.deleteBuffer(buffer);
            });
          }
        }
      }
    }
  }

  // Waitlist form handler
  const form = document.getElementById('waitlist-form') as HTMLFormElement;
  const message = document.getElementById('form-message') as HTMLDivElement;
  
  if (form) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const formData = new FormData(form);
      const email = formData.get('email') as string;
      
      if (!email) {
        message.textContent = 'Please enter a valid email address';
        message.className = 'form-message error';
        return;
      }
      
      // Store in localStorage for now (in production, this would be an API call)
      const waitlist = JSON.parse(localStorage.getItem('chatter-waitlist') || '[]');
      
      if (waitlist.includes(email)) {
        message.textContent = "You're already on the waitlist!";
        message.className = 'form-message error';
      } else {
        waitlist.push(email);
        localStorage.setItem('chatter-waitlist', JSON.stringify(waitlist));
        
        message.textContent = "Welcome aboard! We'll notify you when Chatter launches.";
        message.className = 'form-message success';
        
        form.reset();
      }
      
      setTimeout(() => {
        message.className = 'form-message';
        message.textContent = '';
      }, 5000);
    });
  }
</script>