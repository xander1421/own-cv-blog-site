---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
  title="Chatter - Private Encrypted Messaging with Metadata Protection"
  description="End-to-end encrypted messaging that protects your metadata, not just content. No phone number required. Sealed Sender, anonymous inboxes, and local AI. Open source."
  image="/chatter-og.png"
  type="website"
>
  <div class="waitlist-container">
    <!-- Hero Section -->
    <section class="hero">
      <canvas id="blackhole-canvas" class="blackhole-canvas"></canvas>

      <div class="hero-inner">
        <span class="eyebrow">Coming Soon</span>
        <h1>Your messages are encrypted.<br/><span class="accent">Your metadata isn't.</span></h1>
        <p class="lead">Most secure messengers protect what you say—but leak who you talk to, when, and how often. Chatter protects everything.</p>

        <form id="waitlist-form" class="hero-form">
          <input type="email" id="email" name="email" placeholder="you@email.com" required />
          <button type="submit"><span>Get Early Access</span></button>
        </form>
        <p id="form-message" class="form-message"></p>
        <p class="form-note">No spam. Open source. GPL-3.0.</p>
      </div>
    </section>

    <!-- Value Props - Horizontal, no boxes -->
    <section class="values">
      <div class="value">
        <div class="value-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
        </div>
        <div class="value-text">
          <strong>Sealed Sender</strong>
          <span>Server never sees who sent the message</span>
        </div>
      </div>
      <div class="value">
        <div class="value-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0110 0v4"/></svg>
        </div>
        <div class="value-text">
          <strong>No Phone Required</strong>
          <span>Just a username. That's it.</span>
        </div>
      </div>
      <div class="value">
        <div class="value-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>
        </div>
        <div class="value-text">
          <strong>Anonymous Inbox</strong>
          <span>Ephemeral mailboxes defeat traffic analysis</span>
        </div>
      </div>
      <div class="value">
        <div class="value-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2"/></svg>
        </div>
        <div class="value-text">
          <strong>Local AI</strong>
          <span>Search stays on your device</span>
        </div>
      </div>
    </section>

    <!-- Big Statement -->
    <section class="statement">
      <h2>Beyond <em>encryption</em></h2>
      <p>Encryption protects your content. We protect your social graph, your communication patterns, your identity. The server knows nothing—by design.</p>
    </section>

    <!-- How it works - Alternating layout -->
    <section class="how-it-works">
      <div class="how-block">
        <div class="how-number">01</div>
        <div class="how-content">
          <h3>Hide your social graph</h3>
          <p>Who you talk to is as sensitive as what you say. Sealed Sender ensures the server never knows who sent a message—only the recipient can decrypt the sender's identity.</p>
        </div>
      </div>

      <div class="how-block reverse">
        <div class="how-number">02</div>
        <div class="how-content">
          <h3>Defeat traffic analysis</h3>
          <p>Anonymous inboxes with blind signatures break the correlation between sender and recipient. Your communication patterns stay invisible to everyone—including us.</p>
        </div>
      </div>

      <div class="how-block">
        <div class="how-number">03</div>
        <div class="how-content">
          <h3>AI without surveillance</h3>
          <p>Search and summarize your messages with Ollama. All inference runs locally on your device. Your data never touches our servers or any cloud.</p>
        </div>
      </div>
    </section>

    <!-- Tech callout - Single clean block -->
    <section class="tech-callout">
      <div class="tech-inner">
        <div class="tech-left">
          <h3>Built in Rust</h3>
          <p>Native performance. No Electron. No browser engine. Lightweight with native Wayland support on Linux.</p>
          <a href="/blog/from-react-to-rust-native-journey" class="tech-link">Why we chose Rust &rarr;</a>
        </div>
        <div class="tech-right">
          <a href="https://github.com/xander1421/chatter" class="github-link">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
            <span>View on GitHub</span>
          </a>
          <span class="license">100% Open Source &middot; GPL-3.0</span>
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
      <p>&copy; 2026 Chatter &middot; Built by <a href="/">Alexandru Pruteanu</a></p>
      <nav>
        <a href="/blog">Blog</a>
        <a href="https://github.com/xander1421">GitHub</a>
        <a href="https://linkedin.com/in/alexandru-prt">LinkedIn</a>
      </nav>
    </footer>
  </div>
</BaseLayout>

<style>
  :global(main) {
    max-width: none !important;
    padding: 0 !important;
    margin: 0 !important;
    width: 100vw !important;
    margin-left: calc(-50vw + 50%) !important;
  }

  :global(.matrix-background),
  :global(.perspective-grid),
  :global(.data-streams),
  :global(.scanlines),
  :global(.hologram-grid),
  :global(.glitch-overlay),
  :global(.noise),
  :global(body::before) {
    display: none !important;
  }

  :global(body) {
    background: #000 !important;
  }

  .waitlist-container {
    background: #000;
    color: #fff;
    min-height: 100vh;
  }

  /* Hero */
  .hero {
    position: relative;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 4rem 2rem;
  }

  .blackhole-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0;
    opacity: 0.7;
  }

  .hero-inner {
    position: relative;
    z-index: 10;
    max-width: 720px;
    text-align: center;
  }

  .eyebrow {
    display: inline-block;
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #667eea;
    margin-bottom: 1.5rem;
  }

  .hero h1 {
    font-size: clamp(2.5rem, 6vw, 4rem);
    font-weight: 700;
    line-height: 1.1;
    margin: 0 0 1.5rem;
    letter-spacing: -0.02em;
  }

  .hero h1 .accent {
    background: linear-gradient(135deg, #667eea, #f093fb);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .lead {
    font-size: 1.25rem;
    color: #999;
    line-height: 1.6;
    margin: 0 0 2.5rem;
  }

  .hero-form {
    display: flex;
    gap: 0.75rem;
    max-width: 420px;
    margin: 0 auto 1rem;
  }

  .hero-form input {
    flex: 1;
    padding: 1rem 1.25rem;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #fff;
    font-size: 1rem;
  }

  .hero-form input::placeholder {
    color: #666;
  }

  .hero-form input:focus {
    outline: none;
    border-color: #667eea;
    background: rgba(255,255,255,0.08);
  }

  .hero-form button {
    padding: 1rem 1.75rem;
    background: linear-gradient(135deg, #667eea, #764ba2);
    border: none;
    border-radius: 8px;
    color: #fff;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .hero-form button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
  }

  .form-message {
    min-height: 1.5rem;
    font-size: 0.9rem;
    margin: 0;
  }

  .form-message.success { color: #4ade80; }
  .form-message.error { color: #f87171; }

  .form-note {
    font-size: 0.8rem;
    color: #555;
    margin: 0.5rem 0 0;
  }

  /* Values - Horizontal strip */
  .values {
    position: relative;
    z-index: 10;
    display: flex;
    justify-content: center;
    gap: 4rem;
    padding: 4rem 2rem;
    background: linear-gradient(180deg, transparent, rgba(0,0,0,0.95));
    flex-wrap: wrap;
  }

  .value {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    max-width: 220px;
  }

  .value-icon {
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    color: #667eea;
  }

  .value-icon svg {
    width: 100%;
    height: 100%;
  }

  .value-text strong {
    display: block;
    font-size: 0.95rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .value-text span {
    font-size: 0.85rem;
    color: #777;
    line-height: 1.4;
  }

  /* Statement */
  .statement {
    position: relative;
    z-index: 10;
    padding: 8rem 2rem;
    text-align: center;
    background: #000;
  }

  .statement h2 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 700;
    margin: 0 0 1.5rem;
    letter-spacing: -0.02em;
  }

  .statement h2 em {
    font-style: normal;
    background: linear-gradient(135deg, #667eea, #f093fb);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .statement p {
    font-size: 1.25rem;
    color: #888;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.7;
  }

  /* How it works */
  .how-it-works {
    position: relative;
    z-index: 10;
    max-width: 900px;
    margin: 0 auto;
    padding: 4rem 2rem 8rem;
  }

  .how-block {
    display: flex;
    align-items: flex-start;
    gap: 3rem;
    margin-bottom: 4rem;
  }

  .how-block.reverse {
    flex-direction: row-reverse;
    text-align: right;
  }

  .how-number {
    flex-shrink: 0;
    font-size: 4rem;
    font-weight: 800;
    line-height: 1;
    background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    opacity: 0.3;
  }

  .how-content h3 {
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0 0 0.75rem;
  }

  .how-content p {
    font-size: 1rem;
    color: #888;
    line-height: 1.7;
    margin: 0;
  }

  /* Tech callout */
  .tech-callout {
    position: relative;
    z-index: 10;
    padding: 4rem 2rem;
    background: rgba(255,255,255,0.02);
    border-top: 1px solid rgba(255,255,255,0.05);
    border-bottom: 1px solid rgba(255,255,255,0.05);
  }

  .tech-inner {
    max-width: 900px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 2rem;
    flex-wrap: wrap;
  }

  .tech-left h3 {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0 0 0.5rem;
  }

  .tech-left p {
    font-size: 0.95rem;
    color: #777;
    margin: 0 0 0.75rem;
    max-width: 400px;
  }

  .tech-link {
    font-size: 0.9rem;
    color: #667eea;
    text-decoration: none;
    font-weight: 500;
  }

  .tech-link:hover {
    color: #f093fb;
  }

  .tech-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.5rem;
  }

  .github-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.25rem;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #fff;
    text-decoration: none;
    font-size: 0.9rem;
    font-weight: 500;
    transition: border-color 0.2s, background 0.2s;
  }

  .github-link svg {
    width: 18px;
    height: 18px;
  }

  .github-link:hover {
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.1);
  }

  .license {
    font-size: 0.75rem;
    color: #555;
  }

  /* Footer */
  .footer {
    position: relative;
    z-index: 10;
    padding: 3rem 2rem;
    text-align: center;
  }

  .footer p {
    font-size: 0.85rem;
    color: #555;
    margin: 0 0 1rem;
  }

  .footer a {
    color: #777;
    text-decoration: none;
  }

  .footer a:hover {
    color: #667eea;
  }

  .footer nav {
    display: flex;
    justify-content: center;
    gap: 2rem;
  }

  .footer nav a {
    font-size: 0.85rem;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .values {
      gap: 2rem;
    }

    .value {
      max-width: 100%;
      width: 100%;
    }

    .hero-form {
      flex-direction: column;
    }

    .how-block,
    .how-block.reverse {
      flex-direction: column;
      text-align: left;
    }

    .how-number {
      font-size: 2.5rem;
    }

    .tech-inner {
      flex-direction: column;
      align-items: flex-start;
    }

    .tech-right {
      align-items: flex-start;
    }
  }
</style>

<script>
  // Black hole shader - Original high quality version
  const canvas = document.getElementById('blackhole-canvas') as HTMLCanvasElement;
  if (canvas) {
    const gl = canvas.getContext('webgl2', {
      alpha: true,
      antialias: true,
      powerPreference: 'high-performance',
      preserveDrawingBuffer: false
    }) || canvas.getContext('webgl', {
      alpha: true,
      antialias: true,
      powerPreference: 'high-performance',
      preserveDrawingBuffer: false
    });

    if (gl) {
      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_uv;
        uniform float u_time;
        uniform vec2 u_resolution;

        #define AA 1
        #define _Speed 3.0
        #define _Steps 8.0
        #define _Size 0.4

        float hash(float x) { return fract(sin(x) * 152754.742); }
        float hash(vec2 x) { return hash(x.x + hash(x.y)); }

        float value(vec2 p, float f) {
          float bl = hash(floor(p * f + vec2(0., 0.)));
          float br = hash(floor(p * f + vec2(1., 0.)));
          float tl = hash(floor(p * f + vec2(0., 1.)));
          float tr = hash(floor(p * f + vec2(1., 1.)));
          vec2 fr = fract(p * f);
          fr = (3.0 - 2.0 * fr) * fr * fr;
          float b = mix(bl, br, fr.x);
          float t = mix(tl, tr, fr.x);
          return mix(b, t, fr.y);
        }

        vec4 background(vec3 ray) {
          vec2 uv = ray.xy;
          if (abs(ray.x) > 0.5) uv.x = ray.z;
          else if (abs(ray.y) > 0.5) uv.y = ray.z;
          float brightness = value(uv * 3.0, 100.0);
          float color = value(uv * 2.0, 20.0);
          brightness = pow(brightness, 256.0) * 100.0;
          brightness = clamp(brightness, 0.0, 1.0);
          vec3 stars = brightness * mix(vec3(0.5, 0.5, 0.6), vec3(0.3, 0.3, 0.4), color) * 0.5;
          float nebula = pow(value(uv * 0.5, 5.0), 8.0) * 0.02;
          vec3 nebulae = vec3(nebula) * vec3(0.2, 0.1, 0.3);
          return vec4(stars + nebulae, 1.0);
        }

        vec4 raymarchDisk(vec3 ray, vec3 zeroPos) {
          vec3 position = zeroPos;
          float lengthPos = length(position.xz);
          float dist = min(1.0, lengthPos * (1.0 / _Size) * 0.5) * _Size * 0.4 * (1.0 / _Steps) / abs(ray.y);
          position += dist * _Steps * ray * 0.5;
          vec2 deltaPos;
          deltaPos.x = -zeroPos.z * 0.01 + zeroPos.x;
          deltaPos.y = zeroPos.x * 0.01 + zeroPos.z;
          deltaPos = normalize(deltaPos - zeroPos.xz);
          float parallel = dot(ray.xz, deltaPos) / sqrt(lengthPos) * 0.5;
          float redShift = parallel + 0.3;
          redShift = clamp(redShift * redShift, 0.0, 1.0);
          float disMix = clamp((lengthPos - _Size * 2.0) * (1.0 / _Size) * 0.24, 0.0, 1.0);
          vec3 insideCol = mix(vec3(0.9, 0.3, 0.9), vec3(0.3, 0.1, 0.3), disMix);
          insideCol *= mix(vec3(0.5, 0.3, 0.5), vec3(2.0, 1.0, 2.0), redShift);
          redShift = (redShift + 0.12) * (redShift + 0.12);
          vec4 o = vec4(0.0);
          for (float i = 0.0; i < _Steps; i++) {
            position -= dist * ray;
            float intensity = clamp(1.0 - abs((i - 0.8) * (1.0 / _Steps) * 2.0), 0.0, 1.0);
            float lp = length(position.xz);
            float distMult = clamp((lp - _Size * 0.75) * (1.0 / _Size) * 1.5, 0.0, 1.0);
            distMult *= clamp((_Size * 10.0 - lp) * (1.0 / _Size) * 0.20, 0.0, 1.0);
            distMult *= distMult;
            float u = lp + u_time * _Size * 0.3 + intensity * _Size * 0.2;
            float rot = mod(u_time * _Speed, 8192.0);
            vec2 xy = vec2(-position.z * sin(rot) + position.x * cos(rot), position.x * sin(rot) + position.z * cos(rot));
            float angle = 0.02 * atan(abs(xy.x / xy.y));
            float noise = value(vec2(angle, u * (1.0 / _Size) * 0.05), 70.0);
            noise = noise * 0.66 + 0.33 * value(vec2(angle, u * (1.0 / _Size) * 0.05), 140.0);
            float extraWidth = noise * (1.0 - clamp(i * (1.0 / _Steps) * 2.0 - 1.0, 0.0, 1.0));
            float alpha = clamp(noise * (intensity + extraWidth) * ((1.0 / _Size) * 10.0 + 0.01) * dist * distMult, 0.0, 1.0);
            vec3 col = 2.0 * mix(vec3(0.3, 0.2, 0.15) * insideCol, insideCol, min(1.0, intensity * 2.0));
            o = clamp(vec4(col * alpha + o.rgb * (1.0 - alpha), o.a * (1.0 - alpha) + alpha), vec4(0.0), vec4(1.0));
            o.rgb += redShift * (intensity + 0.5) * (1.0 / _Steps) * 100.0 * distMult / (lp * lp * (1.0 / _Size) * (1.0 / _Size));
          }
          return clamp(o - 0.005, vec4(0.0), vec4(1.0));
        }

        void Rotate(inout vec3 v, vec2 a) {
          v.yz = cos(a.y) * v.yz + sin(a.y) * vec2(-1, 1) * v.zy;
          v.xz = cos(a.x) * v.xz + sin(a.x) * vec2(-1, 1) * v.zx;
        }

        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 fcr = vec2(fc.x * 0.985 + fc.y * 0.174, fc.y * 0.985 - fc.x * 0.174) + vec2(-0.06, 0.12) * u_resolution;
          vec3 ray = normalize(vec3((fcr - u_resolution * 0.5) / u_resolution.x, 1.0));
          vec3 pos = vec3(0.0, 0.05, -10.0);
          vec2 angle = vec2(u_time * 0.1, 3.14 + 0.1 + 3.14);
          float d = length(pos);
          Rotate(pos, angle);
          angle.xy -= min(0.3 / d, 3.14) * vec2(1.0, 0.5);
          Rotate(ray, angle);
          vec4 col = vec4(0.0), glow = vec4(0.0), outCol = vec4(100.0);
          for (int disks = 0; disks < 12; disks++) {
            for (int h = 0; h < 4; h++) {
              float dotpos = dot(pos, pos);
              float invDist = inversesqrt(dotpos);
              float centDist = dotpos * invDist;
              float stepDist = min(0.92 * abs(pos.y / ray.y), min(centDist * 0.5, centDist * 0.1 + 0.05 * centDist * centDist * (1.0 / _Size)));
              float invDistSqr = invDist * invDist;
              ray = normalize(ray - (stepDist * invDistSqr * _Size * 0.625 * invDist) * pos);
              pos += stepDist * ray;
              glow += vec4(0.9, 0.3, 0.9, 1.0) * (0.01 * stepDist * invDistSqr * invDistSqr * clamp(centDist * 2.0 - 1.2, 0.0, 1.0));
            }
            float d2 = length(pos);
            if (d2 < _Size * 0.1) { outCol = vec4(col.rgb * col.a + glow.rgb * (1.0 - col.a), 1.0); break; }
            else if (d2 > _Size * 1000.0) { vec4 bg = background(ray); outCol = vec4(col.rgb * col.a + bg.rgb * (1.0 - col.a) + glow.rgb * (1.0 - col.a), 1.0); break; }
            else if (abs(pos.y) <= _Size * 0.002) {
              vec4 diskCol = raymarchDisk(ray, pos);
              pos.y = 0.0; pos += abs(_Size * 0.001 / ray.y) * ray;
              col = vec4(diskCol.rgb * (1.0 - col.a) + col.rgb, col.a + diskCol.a * (1.0 - col.a));
            }
          }
          if (outCol.r == 100.0) outCol = vec4(col.rgb + glow.rgb * (col.a + glow.a), 1.0);
          gl_FragColor = vec4(pow(outCol.rgb, vec3(0.6)), 1.0);
        }
      `;

      function compileShader(type: number, source: string): WebGLShader | null {
        const shader = gl.createShader(type);
        if (!shader) return null;
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

      if (vertexShader && fragmentShader) {
        const program = gl.createProgram();
        if (program) {
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);

          if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            gl.useProgram(program);

            let startTime = Date.now();
            let animationId: number;
            let isVisible = true;
            let lastRenderTime = 0;
            const targetFPS = 30; // 30fps is enough for slow animation
            const frameInterval = 1000 / targetFPS;

            function resizeCanvas() {
              const dpr = Math.min(window.devicePixelRatio, 1.5); // Cap DPR for performance
              const scale = window.innerWidth > 768 ? 0.5 : 0.6;
              canvas.width = Math.floor(window.innerWidth * scale * dpr);
              canvas.height = Math.floor(window.innerHeight * scale * dpr);
            }

            function render(currentTime: number) {
              animationId = requestAnimationFrame(render);

              // Skip frame if not visible or not enough time passed
              if (!isVisible) return;
              const delta = currentTime - lastRenderTime;
              if (delta < frameInterval) return;
              lastRenderTime = currentTime - (delta % frameInterval);

              gl.viewport(0, 0, canvas.width, canvas.height);
              gl.uniform1f(timeLocation, (Date.now() - startTime) / 1000);
              gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            const observer = new IntersectionObserver((entries) => { isVisible = entries[0]?.isIntersecting ?? false; }, { threshold: 0.1 });
            observer.observe(canvas);
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            requestAnimationFrame(render);

            window.addEventListener('beforeunload', () => {
              observer.disconnect();
              cancelAnimationFrame(animationId);
            });
          }
        }
      }
    }
  }

  // Waitlist form
  const SUPABASE_URL = 'https://fsnwduufbbqxyylwzabg.supabase.co';
  const SUPABASE_ANON_KEY = 'sb_publishable_pKxCqZDi95BLe4rbTQOdrw_n-wmn17a';

  const form = document.getElementById('waitlist-form') as HTMLFormElement;
  const message = document.getElementById('form-message') as HTMLDivElement;

  if (form) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = (new FormData(form).get('email') as string)?.toLowerCase().trim();
      if (!email) { message.textContent = 'Please enter a valid email'; message.className = 'form-message error'; return; }

      const btn = form.querySelector('button') as HTMLButtonElement;
      btn.disabled = true;
      btn.textContent = 'Joining...';

      try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/waitlist`, {
          method: 'POST',
          headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}`, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' },
          body: JSON.stringify({ email })
        });
        if (response.ok) { message.textContent = "You're in! We'll notify you at launch."; message.className = 'form-message success'; form.reset(); }
        else if (response.status === 409) { message.textContent = "You're already on the list!"; message.className = 'form-message error'; }
        else throw new Error();
      } catch { message.textContent = 'Something went wrong. Try again.'; message.className = 'form-message error'; }
      finally { btn.disabled = false; btn.innerHTML = '<span>Get Early Access</span>'; }

      setTimeout(() => { message.className = 'form-message'; message.textContent = ''; }, 5000);
    });
  }
</script>
